import { useState, useCallback } from 'react'
import type { SvnLogEntry } from '@shared/types'

/**
 * Code review export format
 */
export type ReviewExportFormat = 
  | 'unified-diff'
  | 'git-diff'
  | 'patch'
  | 'reviewboard'
  | 'phabricator'
  | 'github'
  | 'gitlab'
  | 'custom'

/**
 * Code review export options
 */
export interface ReviewExportOptions {
  format: ReviewExportFormat
  includeContext: boolean
  contextLines: number
  includeBinaryInfo: boolean
  includeProperties: boolean
  baseRevision?: number
  headRevision?: number
  customTemplate?: string
}

/**
 * Code review bundle
 */
export interface ReviewBundleExport {
  id: string
  name: string
  description?: string
  format: ReviewExportFormat
  content: string
  files: string[]
  createdAt: number
  metadata: Record<string, unknown>
}

/**
 * Review tool integration config
 */
export interface ReviewToolConfig {
  type: 'reviewboard' | 'phabricator' | 'github' | 'gitlab' | 'custom'
  url: string
  apiKey?: string
  repository?: string
  enabled: boolean
}

/**
 * Hook for code review integration
 */
export function useCodeReviewIntegration() {
  const [reviewTools, setReviewTools] = useState<ReviewToolConfig[]>([])
  const [exportHistory, setExportHistory] = useState<ReviewBundleExport[]>([])
  
  /**
   * Generate unified diff for review
   */
  const generateUnifiedDiff = useCallback(async (
    paths: string[],
    _options: Partial<ReviewExportOptions> = {}
  ): Promise<string> => {
    const diffs: string[] = []
    
    for (const path of paths) {
      try {
        const result = await window.api.svn.diff(path)
        if (result.rawDiff) {
          diffs.push(result.rawDiff)
        }
      } catch (error) {
        diffs.push(`# Error getting diff for ${path}: ${error}`)
      }
    }
    
    return diffs.join('\n\n')
  }, [])
  
  /**
   * Generate patch file
   */
  const generatePatch = useCallback(async (
    paths: string[],
    _options: Partial<ReviewExportOptions> = {}
  ): Promise<string> => {
    const patches: string[] = []
    patches.push('# SVN Patch generated by ShellySVN')
    patches.push(`# Generated: ${new Date().toISOString()}`)
    patches.push(`# Files: ${paths.length}`)
    patches.push('')
    
    for (const path of paths) {
      try {
        const result = await window.api.svn.patch.create([path], 'temp.patch')
        if (result.output) {
          patches.push(`=== ${path}`)
          patches.push(result.output)
        }
      } catch (error) {
        patches.push(`# Error: ${path} - ${error}`)
      }
    }
    
    return patches.join('\n')
  }, [])
  
  /**
   * Generate ReviewBoard compatible format
   */
  const generateReviewBoardFormat = useCallback(async (
    paths: string[],
    options: Partial<ReviewExportOptions> = {}
  ): Promise<string> => {
    const diff = await generateUnifiedDiff(paths, options)
    
    const reviewBoard = {
      diff,
      repository: options.baseRevision ? `r${options.baseRevision}` : 'HEAD',
      files: paths
    }
    
    return JSON.stringify(reviewBoard, null, 2)
  }, [generateUnifiedDiff])
  
  /**
   * Generate Phabricator compatible format
   */
  const generatePhabricatorFormat = useCallback(async (
    paths: string[],
    options: Partial<ReviewExportOptions> = {}
  ): Promise<string> => {
    const diff = await generateUnifiedDiff(paths, options)
    
    const phab = {
      diff,
      sourceMachine: 'ShellySVN',
      sourcePath: paths.join(':'),
      creationMethod: 'svn'
    }
    
    return JSON.stringify(phab, null, 2)
  }, [generateUnifiedDiff])
  
  /**
   * Generate GitHub PR compatible format
   */
  const generateGitHubFormat = useCallback(async (
    paths: string[],
    logEntry?: SvnLogEntry
  ): Promise<string> => {
    const diff = await generateUnifiedDiff(paths)
    
    let body = '## SVN Changes\n\n'
    
    if (logEntry) {
      body += `**Revision:** r${logEntry.revision}\n`
      body += `**Author:** ${logEntry.author}\n`
      body += `**Message:**\n\`\`\`\n${logEntry.message}\n\`\`\`\n\n`
    }
    
    body += `**Files Changed:** ${paths.length}\n`
    for (const path of paths) {
      body += `- ${path}\n`
    }
    
    body += '\n## Diff\n\n```diff\n' + diff + '\n```\n'
    
    return body
  }, [generateUnifiedDiff])
  
  /**
   * Generate GitLab MR compatible format
   */
  const generateGitLabFormat = useCallback(async (
    paths: string[],
    logEntry?: SvnLogEntry
  ): Promise<string> => {
    return generateGitHubFormat(paths, logEntry)
  }, [generateGitHubFormat])
  
  /**
   * Export for code review
   */
  const exportForReview = useCallback(async (
    paths: string[],
    format: ReviewExportFormat,
    options: Partial<ReviewExportOptions> = {}
  ): Promise<ReviewBundleExport> => {
    let content: string
    
    switch (format) {
      case 'unified-diff':
        content = await generateUnifiedDiff(paths, options)
        break
      case 'patch':
        content = await generatePatch(paths, options)
        break
      case 'reviewboard':
        content = await generateReviewBoardFormat(paths, options)
        break
      case 'phabricator':
        content = await generatePhabricatorFormat(paths, options)
        break
      case 'github':
        content = await generateGitHubFormat(paths)
        break
      case 'gitlab':
        content = await generateGitLabFormat(paths)
        break
      case 'git-diff':
        content = await generateUnifiedDiff(paths, options)
        break
      default:
        content = await generateUnifiedDiff(paths, options)
    }
    
    const export_: ReviewBundleExport = {
      id: `review-export-${Date.now()}`,
      name: `Review Export ${new Date().toLocaleDateString()}`,
      format,
      content,
      files: paths,
      createdAt: Date.now(),
      metadata: {
        contextLines: options.contextLines,
        includeContext: options.includeContext
      }
    }
    
    setExportHistory(prev => [...prev, export_])
    
    return export_
  }, [
    generateUnifiedDiff,
    generatePatch,
    generateReviewBoardFormat,
    generatePhabricatorFormat,
    generateGitHubFormat,
    generateGitLabFormat
  ])
  
  /**
   * Copy to clipboard
   */
  const copyToClipboard = useCallback(async (content: string): Promise<void> => {
    await navigator.clipboard.writeText(content)
  }, [])
  
  /**
   * Download as file
   */
  const downloadAsFile = useCallback((export_: ReviewBundleExport): void => {
    const extension = export_.format === 'patch' ? '.patch' : '.diff'
    const filename = `${export_.name.replace(/\s+/g, '-')}${extension}`
    
    const blob = new Blob([export_.content], { type: 'text/plain' })
    const url = URL.createObjectURL(blob)
    
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    a.click()
    
    URL.revokeObjectURL(url)
  }, [])
  
  /**
   * Add review tool configuration
   */
  const addReviewTool = useCallback((config: Omit<ReviewToolConfig, 'enabled'>): void => {
    const tool: ReviewToolConfig = {
      ...config,
      enabled: true
    }
    setReviewTools(prev => [...prev, tool])
  }, [])
  
  /**
   * Remove review tool
   */
  const removeReviewTool = useCallback((type: ReviewToolConfig['type']): void => {
    setReviewTools(prev => prev.filter(t => t.type !== type))
  }, [])
  
  return {
    reviewTools,
    exportHistory,
    exportForReview,
    generateUnifiedDiff,
    generatePatch,
    copyToClipboard,
    downloadAsFile,
    addReviewTool,
    removeReviewTool
  }
}

export default useCodeReviewIntegration
